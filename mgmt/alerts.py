"""
Alert Management System for MGMT (Phase 9)

Provides functions for managing alerts generated by the component monitor.
Alerts are displayed in the GUI dashboard and can be acknowledged/resolved by users.

Alert Lifecycle:
----------------
1. ACTIVE: Alert triggered by monitor (component down, threshold exceeded, etc.)
2. ACKNOWLEDGED: User acknowledges alert but issue not resolved
3. RESOLVED: Condition cleared (component recovered, threshold back to normal)
4. SUPPRESSED: User manually suppresses alert (false positive, planned maintenance)

Alert Severity Levels:
----------------------
- INFO: Informational (component registered, volume created)
- WARNING: Non-critical issue (stale heartbeat, approaching capacity)
- ERROR: Service degradation (single replica down, IO errors)
- CRITICAL: Service outage (component down, pool full, data loss risk)
"""

from datetime import datetime, timedelta
from typing import List, Dict, Any, Optional
from sqlalchemy.orm import Session

from mgmt.models import AlertHistory, AlertSeverity, AlertStatus
from mgmt.database import SessionLocal

# For Phase 9, we use AlertHistory for alert storage
Alert = AlertHistory  # Alias for compatibility


def get_active_alerts(severity: Optional[str] = None, limit: int = 50) -> List[Alert]:
    """
    Get unresolved alerts, optionally filtered by severity.
    
    Args:
        severity: Filter by severity ('info', 'warning', 'error', 'critical')
        limit: Maximum number of alerts to return
    
    Returns:
        List of Alert objects
    """
    db = SessionLocal()
    try:
        # Filter for unresolved alerts (status != RESOLVED and resolved_at is NULL)
        query = db.query(Alert).filter(Alert.resolved_at == None)
        
        if severity:
            query = query.filter_by(severity=severity)
        
        query = query.order_by(Alert.fired_at.desc()).limit(limit)
        return query.all()
    finally:
        db.close()


def get_recent_alerts(hours: int = 24, limit: int = 100) -> List[Alert]:
    """
    Get all alerts from the past N hours (resolved and unresolved).
    
    Args:
        hours: Number of hours to look back
        limit: Maximum number of alerts to return
    
    Returns:
        List of Alert objects
    """
    db = SessionLocal()
    try:
        cutoff = datetime.utcnow() - timedelta(hours=hours)
        query = (
            db.query(Alert)
            .filter(Alert.fired_at >= cutoff)
            .order_by(Alert.fired_at.desc())
            .limit(limit)
        )
        return query.all()
    finally:
        db.close()


def get_alert_by_id(alert_id: int) -> Optional[Alert]:
    """
    Get specific alert by alert_id (integer primary key).
    
    Args:
        alert_id: Alert ID (integer)
    
    Returns:
        Alert object or None if not found
    """
    db = SessionLocal()
    try:
        return db.query(Alert).filter_by(id=alert_id).first()
    finally:
        db.close()


def acknowledge_alert(alert_id: int, username: str) -> bool:
    """
    Mark alert as acknowledged by a user.
    
    Args:
        alert_id: Alert ID (integer)
        username: Username of acknowledging user
    
    Returns:
        True if successful, False if alert not found
    """
    db = SessionLocal()
    try:
        alert = db.query(Alert).filter_by(id=alert_id).first()
        if not alert:
            return False
        
        alert.status = AlertStatus.ACKNOWLEDGED
        alert.acknowledged_at = datetime.utcnow()
        # Note: acknowledged_by_user_id should be user.id, but for now just update timestamp
        db.commit()
        print(f"[MGMT Alerts] Acknowledged: {alert_id} by {username}")
        return True
    finally:
        db.close()


def resolve_alert(alert_id: int) -> bool:
    """
    Mark alert as resolved.
    
    Args:
        alert_id: Alert ID (integer)
    
    Returns:
        True if successful, False if alert not found
    """
    db = SessionLocal()
    try:
        alert = db.query(Alert).filter_by(id=alert_id).first()
        if not alert:
            return False
        
        alert.status = AlertStatus.RESOLVED
        alert.resolved_at = datetime.utcnow()
        db.commit()
        print(f"[MGMT Alerts] Resolved: {alert_id}")
        return True
    finally:
        db.close()


def get_alert_counts() -> Dict[str, int]:
    """
    Get counts of active alerts by severity.
    
    Returns:
        Dictionary with keys: total, critical, error, warning, info
    """
    db = SessionLocal()
    try:
        # Count alerts where resolved_at is NULL (not resolved)
        active_alerts = db.query(Alert).filter(Alert.resolved_at == None).all()
        
        counts = {
            "total": len(active_alerts),
            "critical": 0,
            "error": 0,
            "warning": 0,
            "info": 0,
        }
        
        for alert in active_alerts:
            severity = alert.severity.value.lower() if alert.severity else "info"
            if severity in counts:
                counts[severity] += 1
        
        return counts
    finally:
        db.close()


def create_manual_alert(
    title: str,
    message: str,
    severity: str = "info",
    component_type: Optional[str] = None,
    component_id: Optional[str] = None,
    details: Optional[Dict[str, Any]] = None,
) -> Alert:
    """
    Manually create an alert (for admin use or custom triggers).
    
    Args:
        title: Alert title
        message: Alert message/description
        severity: 'info', 'warning', 'error', or 'critical'
        component_type: Optional component type ('MDM', 'SDS', 'SDC')
        component_id: Optional component identifier
        details: Optional JSON-serializable details
    
    Returns:
        Created Alert object
    """
    db = SessionLocal()
    try:
        # Generate unique alert_id
        timestamp = int(datetime.utcnow().timestamp() * 1000)
        alert_id = f"manual_{timestamp}"
        
        alert = Alert(
            alert_id=alert_id,
            severity=severity,
            component_type=component_type,
            component_id=component_id,
            title=title,
            message=message,
            details=details,
            created_at=datetime.utcnow(),
        )
        db.add(alert)
        db.commit()
        db.refresh(alert)
        print(f"[MGMT Alerts] Created manual alert: {alert_id}")
        return alert
    finally:
        db.close()


def delete_old_alerts(days: int = 30) -> int:
    """
    Delete resolved alerts older than N days.
    
    Args:
        days: Number of days to retain alerts
    
    Returns:
        Number of alerts deleted
    """
    db = SessionLocal()
    try:
        cutoff = datetime.utcnow() - timedelta(days=days)
        deleted = (
            db.query(Alert)
            .filter(Alert.resolved_at != None)
            .filter(Alert.fired_at < cutoff)
            .delete()
        )
        db.commit()
        if deleted > 0:
            print(f"[MGMT Alerts] Deleted {deleted} old resolved alerts")
        return deleted
    finally:
        db.close()


def get_alert_history_summary(hours: int = 24) -> Dict[str, Any]:
    """
    Get summary statistics of alerts over the past N hours.
    
    Args:
        hours: Number of hours to analyze
    
    Returns:
        Dictionary with alert statistics
    """
    db = SessionLocal()
    try:
        cutoff = datetime.utcnow() - timedelta(hours=hours)
        alerts = db.query(Alert).filter(Alert.fired_at >= cutoff).all()
        
        total = len(alerts)
        resolved = sum(1 for a in alerts if a.resolved_at is not None)
        acknowledged = sum(1 for a in alerts if a.acknowledged_at is not None and a.resolved_at is None)
        active = sum(1 for a in alerts if a.resolved_at is None)
        
        by_severity = {"critical": 0, "error": 0, "warning": 0, "info": 0}
        for alert in alerts:
            severity = alert.severity.value.lower() if alert.severity else "info"
            if severity in by_severity:
                by_severity[severity] += 1
        
        return {
            "period_hours": hours,
            "total_alerts": total,
            "active": active,
            "acknowledged": acknowledged,
            "resolved": resolved,
            "by_severity": by_severity,
        }
    finally:
        db.close()


def format_alert_for_display(alert: Alert) -> Dict[str, Any]:
    """
    Format alert object for GUI display.
    
    Args:
        alert: Alert database object (AlertHistory)
    
    Returns:
        Dictionary with formatted alert data
    """
    return {
        "id": alert.id,
        "severity": alert.severity.value if alert.severity else "info",
        "status": alert.status.value if alert.status else "active",
        "message": alert.message or "",
        "component_id": alert.component_id or "",
        "fired_at": alert.fired_at.isoformat() if alert.fired_at else None,
        "age_seconds": (datetime.utcnow() - alert.fired_at).total_seconds() if alert.fired_at else 0,
        "acknowledged_at": alert.acknowledged_at.isoformat() if alert.acknowledged_at else None,
        "resolved_at": alert.resolved_at.isoformat() if alert.resolved_at else None,
        "metric_value": alert.metric_value,
        "threshold_value": alert.threshold_value,
    }
